# **쇼핑몰 상태 관리(State Management) 전략**

Next.js 환경에서 효율적인 데이터 관리를 위해 상태(State)를 **Server State**, **Global State**, **Local State** 세 가지로 명확히 구분하여 관리하는 전략을 제안합니다.

## **1\. Server State (서버 상태)**

API를 통해 서버로부터 받아오는 모든 데이터를 의미합니다.

* **해당 데이터:** 상품 목록, 주문 내역, 사용자 정보 등  
* **특징:**  
  * 비동기적으로 가져와야 합니다.  
  * 클라이언트가 직접 소유하지 않고, 서버 데이터의 '캐시(Cache)'에 가깝습니다.  
  * 언제든지 서버에서 변경될 수 있어 최신 상태 유지가 중요합니다. (Stale vs Fresh)  
* **✅ 추천 도구: TanStack Query (구 React Query)**  
* **선택 이유:**  
  * **간결한 비동기 관리:** isLoading, isError, data 상태를 자동으로 관리해주어 코드가 매우 깔끔해집니다.  
  * **강력한 캐싱:** 한 번 불러온 데이터를 캐싱하여 불필요한 API 호출을 줄여줍니다.  
  * **자동 리프레시:** 사용자가 브라우저 탭을 다시 활성화하거나 네트워크가 재연결될 때 데이터를 자동으로 다시 가져와 최신 상태를 유지해줍니다.  
* **적용 대상 API:**  
  * GET /products  
  * GET /products/{id}  
  * GET /v1/order 등 모든 GET 요청

## **2\. Global State (전역 상태)**

애플리케이션의 여러 컴포넌트가 공유해야 하는 클라이언트 상태를 의미합니다.

### **2.1. 인증 상태 (Authentication)**

* **해당 데이터:** 사용자의 로그인 여부, 액세스 토큰, 프로필 정보 등  
* **✅ 추천 도구: React Context API**  
* **선택 이유:**  
  * 데이터 변경 빈도가 낮고, 앱 전반에 걸쳐 '읽기' 위주로 사용됩니다.  
  * 별도의 라이브러리 설치 없이 React의 기본 기능만으로 충분히 구현 가능합니다.  
  * SessionProvider와 같은 형태로 앱 최상단을 감싸주면 관리가 편합니다.

### **2.2. 장바구니 (Shopping Cart)**

* **해당 데이터:** 장바구니에 담긴 상품 목록, 각 상품의 수량, 총 가격 등  
* **특징:**  
  * API 명세에 장바구니 기능이 없어 클라이언트 측에서 모든 로직(추가, 삭제, 수정)을 처리해야 합니다.  
  * 사용자 인터랙션에 따라 상태 변경이 잦습니다.  
* **✅ 추천 도구: Zustand**  
* **선택 이유:**  
  * **매우 간단한 사용법:** Context API나 Redux에 비해 보일러플레이트(반복적인 초기 설정 코드)가 거의 없습니다.  
  * **뛰어난 성능:** 컴포넌트가 스토어(Store)의 특정 값만 구독할 수 있어 불필요한 리렌더링을 쉽게 방지할 수 있습니다.  
  * **Context Provider 불필요:** 앱을 Provider로 감쌀 필요 없이, 필요한 컴포넌트에서 훅(hook)을 호출하여 바로 사용할 수 있습니다.

## **3\. Local State (지역 상태)**

특정 컴포넌트 내에서만 사용되고 다른 곳과 공유할 필요가 없는 상태를 의미합니다.

* **해당 데이터:**  
  * Input, Textarea 등 폼(Form)의 입력 값  
  * 모달(Modal)이나 토글(Toggle)의 열림/닫힘 상태  
  * 특정 UI 요소의 활성화 여부  
* **✅ 추천 도구: useState, useReducer**  
* **선택 이유:**  
  * React에 내장된 가장 기본적인 상태 관리 기능입니다.  
  * 상태의 범위를 해당 컴포넌트로 명확하게 한정할 수 있어 가장 직관적이고 관리하기 쉽습니다.

## **4\. 전략 요약**

| 상태 종류 | 예시 데이터 | 추천 도구 |
| :---- | :---- | :---- |
| **Server State** | 상품, 주문 내역 | **TanStack Query** |
| **Global State** | 로그인 상태, 장바구니 | **Context API** (인증), **Zustand** (장바구니) |
| **Local State** | 폼 입력 값, 모달 on/off | **useState, useReducer** |

이처럼 상태의 성격에 따라 관리 방식을 분리하면, 데이터 흐름을 예측하기 쉬워지고 애플리케이션의 성능과 유지보수성을 크게 향상시킬 수 있습니다.